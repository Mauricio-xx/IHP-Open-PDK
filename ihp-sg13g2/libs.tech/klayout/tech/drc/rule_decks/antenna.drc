# frozen_string_literal: true

#=========================================================================================
# Copyright 2025 IHP PDK Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#=========================================================================================

#====================================================================================================================
#--------------------------------------------- IHP-SG13G2 DRC RULE DECK ---------------------------------------------
#====================================================================================================================
require 'time'
require 'logger'
require 'json'
require 'pathname'

exec_start_time = Time.now

# Custom formatter including timestamp and memory usage
formatter = proc do |_severity, datetime, _progname, msg|
  memory_usage = "#{RBA::Timer.memory_size / 1024}K"
  "#{datetime}: Memory Usage (#{memory_usage}) : #{msg}\n"
end

# Create file logger
file_logger = Logger.new($log)
file_logger.formatter = formatter

# Create stdout logger
stdout_logger = Logger.new($stdout)
stdout_logger.formatter = formatter

# MultiLogger class to broadcast to multiple loggers
class MultiLogger
  def initialize(*targets)
    @targets = targets
  end

  def info(msg)
    @targets.each { |t| t.info(msg) }
  end

  def warn(msg)
    @targets.each { |t| t.warn(msg) }
  end

  def error(msg)
    @targets.each { |t| t.error(msg) }
  end
end

# Use the multi-logger for your application
logger = MultiLogger.new(stdout_logger, file_logger)

#================================================
#----------------- FILE SETUP -------------------
#================================================

logger.info("Starting running IHP-SG13G2 Klayout DRC runset on #{$input}")
logger.info("Ruby Version for klayout: #{RUBY_VERSION}")

if $input
  if $topcell
    source($input, $topcell)
  else
    source($input)
  end
end

logger.info('Loading database to memory is complete.')

if $report
  logger.info("IHP-SG13G2 Klayout DRC runset output at: #{$report}")
  report('DRC Run Report at', $report)
else
  layout_dir = Pathname.new(RBA::CellView.active.filename).parent.realpath
  report_path = layout_dir.join('sg13g2_drc_main.lyrdb').to_s
  logger.info("IHP-SG13G2 Klayout DRC runset output at default location: #{report_path}")
  report('DRC Run Report at', report_path)
end

#================================================
#------------------ SWITCHES --------------------
#================================================

logger.info('Evaluate switches.')

def bool_check?(obj)
  obj.to_s.downcase == 'true'
end

TABLE_NAME = $table_name || 'main'

logger.info("table_name selected  #{TABLE_NAME}")

# Run mode setup
def setup_run_mode(run_mode)
  case run_mode
  when 'tiling'
    tiles(500.um)
    tile_borders(30.um)
  when 'flat'
    flat
  else
    deep
  end
end

# threads
threads($thr.to_i)
logger.info("Klayout will use #{$thr} thread(s)")

# Run mode
setup_run_mode($run_mode)
logger.info("#{$run_mode} mode is enabled for #{TABLE_NAME} table.")

# FEOL
FEOL = !bool_check?($no_feol)
logger.info("FEOL enabled: #{FEOL}")

# BEOL
BEOL = !bool_check?($no_beol)
logger.info("BEOL enabled: #{BEOL}")

# OFFGRID
OFFGRID = !bool_check?($no_offgrid)
logger.info("OffGrid enabled: #{OFFGRID}")

# PreCheck DRC
PRECHECK_DRC = bool_check?($precheck_drc)
logger.info("PreCheck DRC enabled: #{PRECHECK_DRC}")

# Connectivity rules
conn_tables = %w[main nwell nbulay]
CONNECTIVITY_RULES = conn_tables.include?(TABLE_NAME)
logger.info("CONNECTIVITY_RULES enabled: #{CONNECTIVITY_RULES} for table #{TABLE_NAME}")

#================================================
#------------- LAYERS DEFINITIONS ---------------
#================================================

# frozen_string_literal: true

#=========================================================================================
# Copyright 2025 IHP PDK Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#=========================================================================================
#================================================
#------------- LAYERS DEFINITIONS ---------------
#================================================

polygons_count = 0
logger.info('Read in polygons from layers.')

def get_polygons(layer, data_type)
  ps = polygons(layer, data_type)
  $run_mode == 'deep' ? ps : ps.merged
end

activ_drw = get_polygons(1, 0)
count = activ_drw.count
logger.info("activ_drw has #{count} polygons")
polygons_count += count

gatpoly_drw = get_polygons(5, 0)
count = gatpoly_drw.count
logger.info("gatpoly_drw has #{count} polygons")
polygons_count += count

cont_drw = get_polygons(6, 0)
count = cont_drw.count
logger.info("cont_drw has #{count} polygons")
polygons_count += count

nsd_block = get_polygons(7, 21)
count = nsd_block.count
logger.info("nsd_block has #{count} polygons")
polygons_count += count

metal1_drw = get_polygons(8, 0)
count = metal1_drw.count
logger.info("metal1_drw has #{count} polygons")
polygons_count += count

metal2_drw = get_polygons(10, 0)
count = metal2_drw.count
logger.info("metal2_drw has #{count} polygons")
polygons_count += count

psd_drw = get_polygons(14, 0)
count = psd_drw.count
logger.info("psd_drw has #{count} polygons")
polygons_count += count

digisub_drw = get_polygons(16, 0)
count = digisub_drw.count
logger.info("digisub_drw has #{count} polygons")
polygons_count += count

via1_drw = get_polygons(19, 0)
count = via1_drw.count
logger.info("via1_drw has #{count} polygons")
polygons_count += count

via2_drw = get_polygons(29, 0)
count = via2_drw.count
logger.info("via2_drw has #{count} polygons")
polygons_count += count

metal3_drw = get_polygons(30, 0)
count = metal3_drw.count
logger.info("metal3_drw has #{count} polygons")
polygons_count += count

nwell_drw = get_polygons(31, 0)
count = nwell_drw.count
logger.info("nwell_drw has #{count} polygons")
polygons_count += count

pwell_block = get_polygons(46, 21)
count = pwell_block.count
logger.info("pwell_block has #{count} polygons")
polygons_count += count

via3_drw = get_polygons(49, 0)
count = via3_drw.count
logger.info("via3_drw has #{count} polygons")
polygons_count += count

metal4_drw = get_polygons(50, 0)
count = metal4_drw.count
logger.info("metal4_drw has #{count} polygons")
polygons_count += count

via4_drw = get_polygons(66, 0)
count = via4_drw.count
logger.info("via4_drw has #{count} polygons")
polygons_count += count

metal5_drw = get_polygons(67, 0)
count = metal5_drw.count
logger.info("metal5_drw has #{count} polygons")
polygons_count += count

recog_diode = get_polygons(99, 31)
count = recog_diode.count
logger.info("recog_diode has #{count} polygons")
polygons_count += count

topvia1_drw = get_polygons(125, 0)
count = topvia1_drw.count
logger.info("topvia1_drw has #{count} polygons")
polygons_count += count

topmetal1_drw = get_polygons(126, 0)
count = topmetal1_drw.count
logger.info("topmetal1_drw has #{count} polygons")
polygons_count += count

topvia2_drw = get_polygons(133, 0)
count = topvia2_drw.count
logger.info("topvia2_drw has #{count} polygons")
polygons_count += count

topmetal2_drw = get_polygons(134, 0)
count = topmetal2_drw.count
logger.info("topmetal2_drw has #{count} polygons")
polygons_count += count

logger.info("Total no. of polygons in the design is #{polygons_count}")

#================================================
# -------------------- UTILS --------------------
#================================================

# Method to get DRC values from JSON files
def get_drc_values(logger)
  tech_rules = {}
  if $drc_json && $drc_json != $drc_json_default
    begin
      tech_drc_content = File.read($drc_json)
      tech_drc_data = JSON.parse(tech_drc_content)
      tech_rules = tech_drc_data['drc_rules'] || {}
      logger.info("Loaded TECH DRC rules values from #{$drc_json}")
    rescue StandardError => e
      logger.error("Error reading TECH DRC rules from #{$drc_json}: #{e.message}")
    end
  end

  begin
    default_drc_content = File.read($drc_json_default)
    default_drc_data = JSON.parse(default_drc_content)
    default_rules = default_drc_data['drc_rules'] || {}
    logger.info("Loaded default DRC rules values from #{$drc_json_default}")
  rescue StandardError => e
    logger.error("Error reading default DRC rules from #{$drc_json_default}: #{e.message}")
    return {}
  end

  merged_rules = tech_rules.merge(default_rules)

  # Report any fallback rules used
  missing_keys = default_rules.keys - tech_rules.keys
  unless missing_keys.empty?
    logger.warn('The following rules values were missing in tech json and default values were used:')
    missing_keys.each { |rule| logger.warn("  - #{rule}") }
  end

  merged_rules
end

# Extract DRC rules values from the JSON file
drc_rules = get_drc_values(logger)


#================================================
#-------------- COMMON DERIVATIONS --------------
#================================================

# === LAYOUT EXTENT ===
CHIP = extent.sized(0.0)
chip_area = CHIP.area
chip_bbox = CHIP.bbox
chip_w = chip_bbox.width
chip_l = chip_bbox.height

logger.info("Total area of the design is #{chip_area} um^2.")
logger.info("The design dimensions are #{chip_w} µm * #{chip_l} µm.")

# Enable tiling if chip area exceeds 100,000 µm²
en_tiles = chip_area > 1_000_000.um2

# === General Derivations ===
logger.info('Starting general IHP-SG13G2 derivations.')

# Pwell
logger.info('Starting Pwell derivations')
pwell_allowed = CHIP.not(pwell_block)
digisub_gap = digisub_drw.not(digisub_drw.sized(-1.nm))
pwell = pwell_allowed.not(nwell_drw).not(digisub_gap)



#================================================
#----------------- MAIN RUNSET ------------------
#================================================

logger.info('Starting IHP-SG13G2 DRC rules.')

# === FEOL ===
logger.info('Running all FEOL rules') if FEOL
# === BEOL ===
logger.info('Running all BEOL rules') if BEOL

if BEOL
  #================================================
  #----------------- 7.1 Antenna Rules ------------
  #================================================

  logger.info('Starting 7.1 Antenna Rules table')
  nactiv  = activ_drw.not(psd_drw.join(nsd_block))
  pactiv  = activ_drw.and(psd_drw)
  # Antenna Rules Derivations
  #poly_con      = gatpoly_drw.not(res_mk)
  gate = gatpoly_drw.and(activ_drw) # The gate is the intersection of the gate poly and the active layer
  poly_on_field = gatpoly_drw.not(activ_drw) # GatPoly over Field Oxide: GatPoly that is not over Activ
  dantenna = nactiv.and(recog_diode).and(pwell)
  dpantenna = pactiv.and(recog_diode).and(nwell_drw)
  diode = dantenna.or(dpantenna) # Diode is either dantenna or dpantenna
  
  # Initial Connectivity
  connect(poly_on_field, gate)
  connect(gate, cont_drw)
  connect(poly_on_field, cont_drw)
  connect(diode, cont_drw)

  # Rule Ant.a: Max. ratio of GatPoly over field oxide area to connected Gate area

  logger.info('Executing rule Ant.a')

  ant_a_ratio = drc_rules['Ant_a'].to_f # Get the Ant.a ratio from the JSON rules
  ant_a_errors = antenna_check(gate, poly_on_field, ant_a_ratio)
  ant_a_errors.output('Ant.a', "7.1 Ant.a: Max. ratio of GatPoly over field oxide area to connected Gate area: #{ant_a_ratio}")

# Rule Ant.c: Contact Area Ratio
logger.info('Executing rule Ant.c')
ant_c_ratio = drc_rules['Ant_c'].to_f # Get the Ant.c ratio from the JSON rules

# Filter for violations and output
ant_c_errors = antenna_check(gate, cont_drw, ant_c_ratio)
ant_c_errors.output('Ant.c', "7.1 Ant.c: Max. ratio of Cont area to connected Gate area: #{ant_c_ratio}")

# Cumulative Antenna Ratio Calculations: For Ant.b, Ant.e
logger.info('Calculating cumulative antenna ratios')

# Check Metal 1
connect(cont_drw, metal1_drw)
ar_m1 = evaluate_nets(gate, { 'm' => metal1_drw }, "put('m1_ratio', area(m) / area)")

# Connect and Check Via 1
connect(metal1_drw, via1_drw)
ar_v1 = evaluate_nets(gate, { 'v' => via1_drw }, "put('v1_ratio', area(v) / area)")

# Connect and Check Metal 2
connect(via1_drw, metal2_drw)
ar_m2 = evaluate_nets(gate, { 'm' => metal2_drw }, "put('m2_ratio', area(m) / area)")

# Connect and Check Via 2
connect(metal2_drw, via2_drw)
ar_v2 = evaluate_nets(gate, { 'v' => via2_drw }, "put('v2_ratio', area(v) / area)")

# Connect and Check Metal 3
connect(via2_drw, metal3_drw)
ar_m3 = evaluate_nets(gate, { 'm' => metal3_drw }, "put('m3_ratio', area(m) / area)")

# Connect and Check Via 3
connect(metal3_drw, via3_drw)
ar_v3 = evaluate_nets(gate, { 'v' => via3_drw }, "put('v3_ratio', area(v) / area)")

# Connect and Check Metal 4
connect(via3_drw, metal4_drw)
ar_m4 = evaluate_nets(gate, { 'm' => metal4_drw }, "put('m4_ratio', area(m) / area)")

# Connect and Check Via 4
connect(metal4_drw, via4_drw)
ar_v4 = evaluate_nets(gate, { 'v' => via4_drw }, "put('v4_ratio', area(v) / area)")

# Connect and Check Metal 5
connect(via4_drw, metal5_drw)
ar_m5 = evaluate_nets(gate, { 'm' => metal5_drw }, "put('m5_ratio', area(m) / area)")

# Connect and Check TopVia 1
connect(metal5_drw, topvia1_drw)
ar_tv1 = evaluate_nets(gate, { 'v' => topvia1_drw }, "put('tv1_ratio', area(v) / area)")

# Connect and Check TopMetal 1
connect(topvia1_drw, topmetal1_drw)
ar_tm1 = evaluate_nets(gate, { 'm' => topmetal1_drw }, "put('tm1_ratio', area(m) / area)")

# Connect and Check TopVia 2
connect(topmetal1_drw, topvia2_drw)
ar_tv2 = evaluate_nets(gate, { 'v' => topvia2_drw }, "put('tv2_ratio', area(v) / area)")

# Connect and Check TopMetal 2
connect(topvia2_drw, topmetal2_drw)
ar_tm2 = evaluate_nets(gate, { 'm' => topmetal2_drw }, "put('tm2_ratio', area(m) / area)")

# Check for diode presence
diode_presence = evaluate_nets(gate, { 'd' => diode }, "put('has_diode', area(d) > 0.16 ? 1 : 0)")


# Rules Ant.b & Ant.e: Cumulative Metal Area Ratio (with and without Diode)
logger.info('Executing rules Ant.b and Ant.e step-by-step for each metal layer')

ant_b_ratio = drc_rules['Ant_b'].to_f # Get the Ant.b ratio from the JSON rules
ant_e_ratio = drc_rules['Ant_e'].to_f # Get the Ant.e ratio from the JSON rules

# Create a base layer with all individual ratios and the diode flag
ar_all_layers = (ar_m1 + ar_m2 + ar_m3 + ar_m4 + ar_m5 + ar_tm1 + ar_tm2 + diode_presence).merged_props
ar_m1.forget; ar_m2.forget; ar_m3.forget; ar_m4.forget; ar_m5.forget; ar_tm1.forget; ar_tm2.forget;

# Check after Metal 1
violation_expr_m1 = "(value('has_diode') == 0 && value('m1_ratio') >= ar_max_no_diode) || (value('has_diode') == 1 && value('m1_ratio') >= ar_max_with_diode)"
ant_be_errors_m1 = ar_all_layers.selected_if(violation_expr_m1, { 'ar_max_no_diode' => ant_b_ratio, 'ar_max_with_diode' => ant_e_ratio })
ant_be_errors_m1.output('Ant.b_and_Ant.e_M1', '7.1 Ant.b/e up to M1: Cumulative metal antenna ratio check.')
ant_be_errors_m1.forget

# Check after Metal 2
ar_all_layers.evaluate("put('sum_m1_m2', value('m1_ratio') + value('m2_ratio'))", {}, true) # Cumulative M1+M2
violation_expr_m2 = "(value('has_diode') == 0 && value('sum_m1_m2') >= ar_max_no_diode) || (value('has_diode') == 1 && value('sum_m1_m2') >= ar_max_with_diode)"
ant_be_errors_m2 = ar_all_layers.selected_if(violation_expr_m2, { 'ar_max_no_diode' => ant_b_ratio, 'ar_max_with_diode' => ant_e_ratio })
ant_be_errors_m2.output('Ant.b_and_Ant.e_M2', '7.1 Ant.b/e up to M2: Cumulative metal antenna ratio check.')
ant_be_errors_m2.forget

# Check after Metal 3
ar_all_layers.evaluate("put('sum_m1_m3', value('sum_m1_m2') + value('m3_ratio'))", {}, true) # Cumulative M1-M3
violation_expr_m3 = "(value('has_diode') == 0 && value('sum_m1_m3') >= ar_max_no_diode) || (value('has_diode') == 1 && value('sum_m1_m3') >= ar_max_with_diode)"
ant_be_errors_m3 = ar_all_layers.selected_if(violation_expr_m3, { 'ar_max_no_diode' => ant_b_ratio, 'ar_max_with_diode' => ant_e_ratio })
ant_be_errors_m3.output('Ant.b_and_Ant.e_M3', '7.1 Ant.b/e up to M3: Cumulative metal antenna ratio check.')
ant_be_errors_m3.forget

# Check after Metal 4
ar_all_layers.evaluate("put('sum_m1_m4', value('sum_m1_m3') + value('m4_ratio'))", {}, true) # Cumulative M1-M4
violation_expr_m4 = "(value('has_diode') == 0 && value('sum_m1_m4') >= ar_max_no_diode) || (value('has_diode') == 1 && value('sum_m1_m4') >= ar_max_with_diode)"
ant_be_errors_m4 = ar_all_layers.selected_if(violation_expr_m4, { 'ar_max_no_diode' => ant_b_ratio, 'ar_max_with_diode' => ant_e_ratio })
ant_be_errors_m4.output('Ant.b_and_Ant.e_M4', '7.1 Ant.b/e up to M4: Cumulative metal antenna ratio check.')
ant_be_errors_m4.forget

# Check after Metal 5
ar_all_layers.evaluate("put('sum_m1_m5', value('sum_m1_m4') + value('m5_ratio'))", {}, true) # Cumulative M1-M5
violation_expr_m5 = "(value('has_diode') == 0 && value('sum_m1_m5') >= ar_max_no_diode) || (value('has_diode') == 1 && value('sum_m1_m5') >= ar_max_with_diode)"
ant_be_errors_m5 = ar_all_layers.selected_if(violation_expr_m5, { 'ar_max_no_diode' => ant_b_ratio, 'ar_max_with_diode' => ant_e_ratio })
ant_be_errors_m5.output('Ant.b_and_Ant.e_M5', '7.1 Ant.b/e up to M5: Cumulative metal antenna ratio check.')
ant_be_errors_m5.forget

# Check after TopMetal 1
ar_all_layers.evaluate("put('sum_m1_tm1', value('sum_m1_m5') + value('tm1_ratio'))", {}, true) # Cumulative M1-TM1
violation_expr_tm1 = "(value('has_diode') == 0 && value('sum_m1_tm1') >= ar_max_no_diode) || (value('has_diode') == 1 && value('sum_m1_tm1') >= ar_max_with_diode)"
ant_be_errors_tm1 = ar_all_layers.selected_if(violation_expr_tm1, { 'ar_max_no_diode' => ant_b_ratio, 'ar_max_with_diode' => ant_e_ratio })
ant_be_errors_tm1.output('Ant.b_and_Ant.e_TM1', '7.1 Ant.b/e up to TM1: Cumulative metal antenna ratio check.')
ant_be_errors_tm1.forget

# Check after TopMetal 2
ar_all_layers.evaluate("put('sum_m1_tm2', value('sum_m1_tm1') + value('tm2_ratio'))", {}, true) # Cumulative M1-TM2
violation_expr_tm2 = "(value('has_diode') == 0 && value('sum_m1_tm2') >= ar_max_no_diode) || (value('has_diode') == 1 && value('sum_m1_tm2') >= ar_max_with_diode)"
ant_be_errors_tm2 = ar_all_layers.selected_if(violation_expr_tm2, { 'ar_max_no_diode' => ant_b_ratio, 'ar_max_with_diode' => ant_e_ratio })
ant_be_errors_tm2.output('Ant.b_and_Ant.e_TM2', '7.1 Ant.b/e up to TM2: Cumulative metal antenna ratio check.')
ant_be_errors_tm2.forget
ar_all_layers.forget

# Rules Ant.d & Ant.f (Vias)
logger.info('Executing rules Ant.d and Ant.f')

ant_d_ratio = drc_rules['Ant_d'].to_f # Get the Ant.d ratio from the JSON rules
ant_f_ratio = drc_rules['Ant_f'].to_f # Get the Ant.f ratio from the JSON rules

# Create a base layer with all individual via ratios and the diode flag
ar_all_vias = (ar_v1 + ar_v2 + ar_v3 + ar_v4 + ar_tv1 + ar_tv2 + diode_presence).merged_props
ar_v1.forget; ar_v2.forget; ar_v3.forget; ar_v4.forget; ar_tv1.forget; ar_tv2.forget; diode_presence.forget

# Check after Via 1
ar_all_vias.evaluate("put('sum_v1', value('v1_ratio'))", {}, true) # Cumulative V1
violation_expr_v1 = "(value('has_diode') == 0 && value('sum_v1') >= ar_max_no_diode) || (value('has_diode') == 1 && value('sum_v1') >= ar_max_with_diode)"
ant_df_errors_v1 = ar_all_vias.selected_if(violation_expr_v1, { 'ar_max_no_diode' => ant_d_ratio, 'ar_max_with_diode' => ant_f_ratio })
ant_df_errors_v1.output('Ant.d_and_Ant.f_V1', '7.1 Ant.d/f up to V1: Cumulative via antenna ratio check.')
ant_df_errors_v1.forget

# Check after Via 2
ar_all_vias.evaluate("put('sum_v1_v2', value('sum_v1') + value('v2_ratio'))", {}, true) # Cumulative V1+V2
violation_expr_v2 = "(value('has_diode') == 0 && value('sum_v1_v2') >= ar_max_no_diode) || (value('has_diode') == 1 && value('sum_v1_v2') >= ar_max_with_diode)"
ant_df_errors_v2 = ar_all_vias.selected_if(violation_expr_v2, { 'ar_max_no_diode' => ant_d_ratio, 'ar_max_with_diode' => ant_f_ratio })
ant_df_errors_v2.output('Ant.d_and_Ant.f_V2', '7.1 Ant.d/f up to V2: Cumulative via antenna ratio check.')
ant_df_errors_v2.forget

# Check after Via 3
ar_all_vias.evaluate("put('sum_v1_v3', value('sum_v1_v2') + value('v3_ratio'))", {}, true) # Cumulative V1-V3
violation_expr_v3 = "(value('has_diode') == 0 && value('sum_v1_v3') >= ar_max_no_diode) || (value('has_diode') == 1 && value('sum_v1_v3') >= ar_max_with_diode)"
ant_df_errors_v3 = ar_all_vias.selected_if(violation_expr_v3, { 'ar_max_no_diode' => ant_d_ratio, 'ar_max_with_diode' => ant_f_ratio })
ant_df_errors_v3.output('Ant.d_and_Ant.f_V3', '7.1 Ant.d/f up to V3: Cumulative via antenna ratio check.')
ant_df_errors_v3.forget

# Check after Via 4
ar_all_vias.evaluate("put('sum_v1_v4', value('sum_v1_v3') + value('v4_ratio'))", {}, true) # Cumulative V1-V4
violation_expr_v4 = "(value('has_diode') == 0 && value('sum_v1_v4') >= ar_max_no_diode) || (value('has_diode') == 1 && value('sum_v1_v4') >= ar_max_with_diode)"
ant_df_errors_v4 = ar_all_vias.selected_if(violation_expr_v4, { 'ar_max_no_diode' => ant_d_ratio, 'ar_max_with_diode' => ant_f_ratio })
ant_df_errors_v4.output('Ant.d_and_Ant.f_V4', '7.1 Ant.d/f up to V4: Cumulative via antenna ratio check.')
ant_df_errors_v4.forget

# Check after TopVia 1
ar_all_vias.evaluate("put('sum_v1_tv1', value('sum_v1_v4') + value('tv1_ratio'))", {}, true) # Cumulative V1-TV1
violation_expr_tv1 = "(value('has_diode') == 0 && value('sum_v1_tv1') >= ar_max_no_diode) || (value('has_diode') == 1 && value('sum_v1_tv1') >= ar_max_with_diode)"
ant_df_errors_tv1 = ar_all_vias.selected_if(violation_expr_tv1, { 'ar_max_no_diode' => ant_d_ratio, 'ar_max_with_diode' => ant_f_ratio })
ant_df_errors_tv1.output('Ant.d_and_Ant.f_TV1', '7.1 Ant.d/f up to TV1: Cumulative via antenna ratio check.')
ant_df_errors_tv1.forget 

# Check after TopVia 2
ar_all_vias.evaluate("put('sum_v1_tv2', value('sum_v1_tv1') + value('tv2_ratio'))", {}, true) # Cumulative V1-TV2
violation_expr_tv2 = "(value('has_diode') == 0 && value('sum_v1_tv2') >= ar_max_no_diode) || (value('has_diode') == 1 && value('sum_v1_tv2') >= ar_max_with_diode)"
ant_df_errors_tv2 = ar_all_vias.selected_if(violation_expr_tv2, { 'ar_max_no_diode' => ant_d_ratio, 'ar_max_with_diode' => ant_f_ratio })
ant_df_errors_tv2.output('Ant.d_and_Ant.f_TV2', '7.1 Ant.d/f up to TV2: Cumulative via antenna ratio check.')
ant_df_errors_tv2.forget 
ar_all_vias.forget 

# Rule Ant.g: Minimum Diode Size
logger.info('Executing rule Ant.g')

ant_g_min_area = drc_rules['Ant_g'].to_f # Get the Ant.g minimum area from the JSON rules

# Expression to check if actual diode area is less than the greater of the fixed minimum
ant_g_errors = diode.with_area(0, ant_g_min_area)
ant_g_errors.output('Ant.g', "7.1 Ant.g: Protection diode size is insufficient. Required area is min #{ant_g_min_area}")
ant_g_errors.forget

end